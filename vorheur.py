#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
This program can be run from the command line. 
Usage: 
    python vorheur.py -h
    python vorheur.py -p 3 -o belle_outer
    python vorheur.py -p 3 -o belle_outer -i belle_pond1,belle_pond2,belle_pond3

This program solves the p-center area coverage problem. The area to be covered must be a polygon defined in a KML file. The input can 
also contain 0, 1 or multiple holes, each being a polygon defined in a separate KML file. 
The outer polygon and hole files must be .kml files (e.g., generated by Google Earth). All input KML files should be in the same path as this program file. 

Key Reference: 
    1. Hu Wei, Alan T. Murray, and Ningchuan Xiao. Solving the continuous space p-centre problem: planning application issues. IMA Journal of Management Mathematics, 17(4): 413 - 425, 10 2006.
    2. Emo Welzl. Smallest enclosing disks (balls and ellipsoids). In Hermann Maurer, editor, New Results and New Trends in Computer Science, pages 359{370, Berlin, Heidelberg, 1991. Springer Berlin Heidelberg.
    3. Atsuo Suzuki and Zvi Drezner. The p-center location problem in an area. Location Science, 4(1):69 { 82, 1996.
    4. Nimrod Megiddo. Linear-time algorithms for linear programming in r3 and related problems. SIAM Journal on Computing, 12(4):759{776, 1983. doi: 10.1137/0212052.                                                                                           
    5. A working paper by the Yanchao Liu, titled "A faster algorithm for the constrained minimum covering circle problem to expedite solving p-center problems in an irregularly shaped area with holes"

@author: Yanchao Liu
"""

import argparse
import matplotlib.pyplot as plt
import numpy as np
from numpy import dot,empty_like
from scipy.spatial import Voronoi
from scipy.spatial import ConvexHull
from matplotlib.backends.backend_pdf import PdfPages
import time
import utm
import simplekml
from polycircles import polycircles
import pandas as pd
from shapely.geometry import Point, Polygon
from operator import itemgetter


###############################################################################
######### BEGIN 3rd Party Code ##########
# 
# Smallest enclosing circle - Library (Python)
# 
# Copyright (c) 2020 Project Nayuki
# https://www.nayuki.io/page/smallest-enclosing-circle
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with this program (see COPYING.txt and COPYING.LESSER.txt).
# If not, see <http://www.gnu.org/licenses/>.
# 

import math, random

# Data conventions: A point is a pair of floats (x, y). A circle is a triple of floats (center x, center y, radius).

# Returns the smallest circle that encloses all the given points. Runs in expected O(n) time, randomized.
# Input: A sequence of pairs of floats or ints, e.g. [(0,5), (3.1,-2.7)].
# Output: A triple of floats representing a circle.
# Note: If 0 points are given, None is returned. If 1 point is given, a circle of radius 0 is returned.
# 
# Initially: No boundary points known
def make_circle(points):
	# Convert to float and randomize order
	shuffled = [(float(x), float(y)) for (x, y) in points]
	random.shuffle(shuffled)
	
	# Progressively add points to circle or recompute circle
	c = None
	for (i, p) in enumerate(shuffled):
		if c is None or not is_in_circle(c, p):
			c = _make_circle_one_point(shuffled[ : i + 1], p)
	return c


# One boundary point known
def _make_circle_one_point(points, p):
	c = (p[0], p[1], 0.0)
	for (i, q) in enumerate(points):
		if not is_in_circle(c, q):
			if c[2] == 0.0:
				c = make_diameter(p, q)
			else:
				c = _make_circle_two_points(points[ : i + 1], p, q)
	return c


# Two boundary points known
def _make_circle_two_points(points, p, q):
	circ = make_diameter(p, q)
	left  = None
	right = None
	px, py = p
	qx, qy = q
	
	# For each point not in the two-point circle
	for r in points:
		if is_in_circle(circ, r):
			continue
		
		# Form a circumcircle and classify it on left or right side
		cross = _cross_product(px, py, qx, qy, r[0], r[1])
		c = make_circumcircle(p, q, r)
		if c is None:
			continue
		elif cross > 0.0 and (left is None or _cross_product(px, py, qx, qy, c[0], c[1]) > _cross_product(px, py, qx, qy, left[0], left[1])):
			left = c
		elif cross < 0.0 and (right is None or _cross_product(px, py, qx, qy, c[0], c[1]) < _cross_product(px, py, qx, qy, right[0], right[1])):
			right = c
	
	# Select which circle to return
	if left is None and right is None:
		return circ
	elif left is None:
		return right
	elif right is None:
		return left
	else:
		return left if (left[2] <= right[2]) else right


def make_diameter(a, b):
	cx = (a[0] + b[0]) / 2
	cy = (a[1] + b[1]) / 2
	r0 = math.hypot(cx - a[0], cy - a[1])
	r1 = math.hypot(cx - b[0], cy - b[1])
	return (cx, cy, max(r0, r1))


def make_circumcircle(a, b, c):
	# Mathematical algorithm from Wikipedia: Circumscribed circle
	ox = (min(a[0], b[0], c[0]) + max(a[0], b[0], c[0])) / 2
	oy = (min(a[1], b[1], c[1]) + max(a[1], b[1], c[1])) / 2
	ax = a[0] - ox;  ay = a[1] - oy
	bx = b[0] - ox;  by = b[1] - oy
	cx = c[0] - ox;  cy = c[1] - oy
	d = (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by)) * 2.0
	if d == 0.0:
		return None
	x = ox + ((ax*ax + ay*ay) * (by - cy) + (bx*bx + by*by) * (cy - ay) + (cx*cx + cy*cy) * (ay - by)) / d
	y = oy + ((ax*ax + ay*ay) * (cx - bx) + (bx*bx + by*by) * (ax - cx) + (cx*cx + cy*cy) * (bx - ax)) / d
	ra = math.hypot(x - a[0], y - a[1])
	rb = math.hypot(x - b[0], y - b[1])
	rc = math.hypot(x - c[0], y - c[1])
	return (x, y, max(ra, rb, rc))


_MULTIPLICATIVE_EPSILON = 1 + 1e-14

def is_in_circle(c, p):
	return c is not None and math.hypot(p[0] - c[0], p[1] - c[1]) <= c[2] * _MULTIPLICATIVE_EPSILON


# Returns twice the signed area of the triangle defined by (x0, y0), (x1, y1), (x2, y2).
def _cross_product(x0, y0, x1, y1, x2, y2):
	return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)

######### END 3rd Party Code ##########
###############################################################################

example_text = '''
Examples:
    python vorheur.py -h
    python vorheur.py -p 3 -o belle_outer
    python vorheur.py -p 3 -o belle_outer -i belle_pond1,belle_pond2,belle_pond3

'''
description_text = '''
Description: 
Run the Voronoi heuristic to cover a polygon with p circles such that no circle’s center lies outside the polygon, no circle’s center drops inside a polygonal hole, and the radius of the largest circle is as small as possible.
The outer polygon and hole files must be .kml files (e.g., generated by Google Earth). 

Citation: 
Yanchao Liu (2021). "A faster algorithm for the constrained minimum covering circle problem to expedite solving p-center problems in an irregularly shaped area with holes", Naval Research Logistics, in print. 
'''

ap = argparse.ArgumentParser(prog='vorheur',
                                 description=description_text,
                                 epilog=example_text,
                                 formatter_class=argparse.RawDescriptionHelpFormatter)
ap.add_argument("-p", "--ndepots", type=int, default=3, help="an integer indicating the number of centers to use")
ap.add_argument("-m", "--method", type=str, default="Liu2021a", help="the CMCC method to use (Wei, Wei_v2, Liu or Liu2021a")
ap.add_argument("-o", "--outer", type=str, default="belle_outer", help="outer polygon kml filename")
ap.add_argument("-i", "--holes", type=str, default="", help="hole polygon kml filenames, separated by comma")
ap.add_argument("-u", "--use_init", type=int, default=0, help="0 for random sample, 1 for read from file")
ap.add_argument("-s", "--sol", type=str, default="vorheur_sol", help="solution kml filename")
ap.add_argument("-f", "--pdf", type=str, default="vorheur_sol", help="solution pdf filename")
ap.add_argument("-l", "--iter", type=str, default="vorheur_iterlog", help="iteration plot pdf filename")
args = vars(ap.parse_args())


np.set_printoptions(threshold=100)  # Print more lines
pmar = 30  # Plot area margin
ndepots = args["ndepots"]
kml_file = args["outer"]+".kml"
if len(args["holes"].strip()) > 0:
    hole_file_names = args["holes"].split(',')
else:
    hole_file_names = []
cmcc_method = args["method"]
read_init_points = args["use_init"]

# Load corners from KML file
border = 0
pd.set_option('display.max_colwidth',1000000)
data = pd.read_table(kml_file,sep='\r\t',header=None,skip_blank_lines=False,engine='python')
foundlable = 0
for i in range(0,len(data)):
    strl = data.iloc[i].to_frame().T
    strl2 = strl.to_string()
    strlist = strl2.split()
    if strlist[2] == '<coordinates>':
        foundlable = 1
        continue
    if foundlable == 1:
        break
minx = 1000000000000
miny = 1000000000000
maxx = 0
maxy = 0
location = list()
utmloc = dict()
for i in range(2,len(strlist)):
    location = strlist[i].split(",")
    templst = utm.from_latlon(float(location[1]),float(location[0]))
    #print(templst)
    if templst[0] <= minx:
        minx = templst[0]
    if templst[0] >= maxx:
        maxx = templst[0]
    if templst[1] <= miny:
        miny = templst[1]
    if templst[1] >= maxy:
        maxy = templst[1]
    temploc = {str(i-1):
             {'x': templst[0],
             'y': templst[1]}}
    utmloc.update(temploc)
utmnumber = templst[2]
utmletter = templst[3]
lenx = maxx - minx
leny = maxy - miny
midx = (maxx + minx)/2
midy = (maxy + miny)/2
sqlen = max(lenx,leny)
origx = midx - sqlen*(0.5 + border)
origy = midy - sqlen*(0.5 + border)

location = list()
sqloc = dict()
for i in range(3,len(strlist)):
    location = strlist[i].split(",")
    templst = utm.from_latlon(float(location[1]),float(location[0]))

    temploc = {str(i-1):
             {'x': (templst[0]-origx)/sqlen/(1+border*2)*100,
             'y': (templst[1]-origy)/sqlen/(1+border*2)*100}}
    sqloc.update(temploc)
corners = np.empty((0,2))
for i in sqloc.keys():
    corners = np.append(corners, np.array(list(sqloc[i].values())))
corners.resize((len(sqloc),2))

# Now load hole files
holes = {}  # empty dictionary to hold hole name and coordinate pairs
for this_hole in hole_file_names:
    data = pd.read_table(this_hole + ".kml",sep='\r\t',header=None,skip_blank_lines=False,engine='python')
    foundlable = 0
    for i in range(0,len(data)):
        strl = data.iloc[i].to_frame().T
        strl2 = strl.to_string()
        strlist = strl2.split()
        if strlist[2] == '<coordinates>':
            foundlable = 1
            continue
        if foundlable == 1:
            break
    location = list()
    sqloc = dict()
    for i in range(3,len(strlist)):
        location = strlist[i].split(",")
        templst = utm.from_latlon(float(location[1]),float(location[0]))

        temploc = {str(i-1):
                 {'x': (templst[0]-origx)/sqlen/(1+border*2)*100,
                 'y': (templst[1]-origy)/sqlen/(1+border*2)*100}}
        sqloc.update(temploc)
    hole = np.empty((0,2))
    for i in sqloc.keys():
        hole = np.append(hole, np.array(list(sqloc[i].values())))
    hole.resize((len(sqloc),2))
    holes.update({this_hole: hole})


# Create outer boundary edges, edge_equations and polygon
edges = np.empty((0,2), dtype = int)
for i in range(len(corners)-1):
    edges = np.append(edges, np.reshape([i, i+1], (1,2)), axis = 0)
edges = np.append(edges, np.reshape([len(corners)-1, 0], (1,2)), axis = 0)
edge_equations = np.empty((len(edges),3))
for i in range(len(edges)):
    x1 = corners[edges[i,0],0]
    y1 = corners[edges[i,0],1]
    x2 = corners[edges[i,1],0]
    y2 = corners[edges[i,1],1]
    edge_equations[i,0] = y2 - y1
    edge_equations[i,1] = x1 - x2
    edge_equations[i,2] = edge_equations[i,0]*x1 + edge_equations[i,1]*y1
polygon = Polygon(corners)

# Create the boundary edges, edge_equations and polygon for each hole
holes_edges = {}
holes_edge_equations = {}
holes_polygon = {}
for this_hole in hole_file_names:
    this_hole_corners = holes[this_hole]
    this_hole_edges = np.empty((0,2), dtype = int)
    for i in range(len(this_hole_corners)-1):
        this_hole_edges = np.append(this_hole_edges, np.reshape([i, i+1], (1,2)), axis = 0)
    this_hole_edges = np.append(this_hole_edges, np.reshape([len(this_hole_corners)-1, 0], (1,2)), axis = 0)
    this_hole_edge_equations = np.empty((len(this_hole_edges),3))
    for i in range(len(this_hole_edges)):
        x1 = this_hole_corners[this_hole_edges[i,0],0]
        y1 = this_hole_corners[this_hole_edges[i,0],1]
        x2 = this_hole_corners[this_hole_edges[i,1],0]
        y2 = this_hole_corners[this_hole_edges[i,1],1]
        this_hole_edge_equations[i,0] = y2 - y1
        this_hole_edge_equations[i,1] = x1 - x2
        this_hole_edge_equations[i,2] = this_hole_edge_equations[i,0]*x1 + this_hole_edge_equations[i,1]*y1
    this_hole_polygon = Polygon(this_hole_corners)
    holes_edges.update({this_hole:this_hole_edges})
    holes_edge_equations.update({this_hole:this_hole_edge_equations})
    holes_polygon.update({this_hole:this_hole_polygon})


# How many line segments in outer polygon?
print("Outer polygon has {0:d} line segments".format(len(edges)))
print("There are {:d} holes: ".format(len(holes)))
total_hole_segs = 0
for key in holes_edges:
    print(key + " has {0:d} line segments".format(len(holes_edges[key])))
    total_hole_segs = total_hole_segs + len(holes_edges[key])
print("Total hole line segments: {:d}".format(total_hole_segs))

def on_which_edge(edge_eqn, p):
    coef = edge_eqn[:,:-1]
    rhs = edge_eqn[:,-1]
    return (np.nonzero(np.abs(np.around(np.dot(coef,p), decimals = 10)) == np.around(np.abs(rhs), decimals = 10)))[0]

def perp( a ) :
    b = empty_like(a)
    b[0] = -a[1]
    b[1] = a[0]
    return b

def seg_intersect(a1,a2, b1,b2) :
    toler = 1e-8
    da = a2-a1
    db = b2-b1
    dp = a1-b1
    dap = perp(da)
    denom = dot( dap, db)
    num = dot( dap, dp )

    x3 = ((num / denom.astype(float))*db + b1)[0]
    y3 = ((num / denom.astype(float))*db + b1)[1]
    if x3 >= min(a1[0], a2[0])-toler and x3 <= max(a1[0], a2[0])+toler and y3 >= min(a1[1],a2[1])-toler and y3 <= max(a1[1],a2[1])+toler and \
    x3 >= min(b1[0], b2[0])-toler and x3 <= max(b1[0], b2[0])+toler and y3 >= min(b1[1],b2[1])-toler and y3 <= max(b1[1],b2[1])+toler:
        return x3,y3
    else:
        return False

# Is the center point of this MCC in the polygon and not in any hole?
def center_feasible(candidate):
    if not Point(np.around(candidate, decimals = 10)).within(polygon):
        return((False,'polygon'))
    for this_hole in hole_file_names:
        if Point(np.around(candidate, decimals = 10)).within(holes_polygon[this_hole]):
            return((False,this_hole))
    return((True,'na'))

# Given a point and a line segment, find the (projection) point on the line segment that is closest to the given point, return the projection point and the distance
def project_point_to_line_segment(point, lineseg):
    result = np.double([0,0])
    vx_lineseg = lineseg[1][0] - lineseg[0][0]
    vy_lineseg = lineseg[1][1] - lineseg[0][1]
    vx_point = point[0] - lineseg[0][0]
    vy_point = point[1] - lineseg[0][1]
    point_dot_lineseg = vx_point*vx_lineseg + vy_point*vy_lineseg
    lineseg_dot_lineseg = vx_lineseg*vx_lineseg + vy_lineseg*vy_lineseg
    l = point_dot_lineseg/lineseg_dot_lineseg
    if l <= 0:
        result[0] = lineseg[0][0]
        result[1] = lineseg[0][1]
    elif l >= 1:
        result[0] = lineseg[1][0]
        result[1] = lineseg[1][1]
    else:
        result[0] = lineseg[0][0] + l*vx_lineseg
        result[1] = lineseg[0][1] + l*vy_lineseg
    return result

# Find the intersection point (if exists) of the bisector of the vertex pair and a line segment
# If found, return the intersection point coordinates and the distance between one vertext to the intersection point
# If not found, return distance -1
def bisect_line_segment_old(vertex_pair = np.array([[3,3], [6, 0]]), lineseg = np.array([[3,6], [3, 4]])):
    toler = 1e-8
    result = np.double([0,0])
    d = 0
    endpt_dist_diff1 = ((lineseg[0][0] - vertex_pair[0][0])**2 + (lineseg[0][1] - vertex_pair[0][1])**2)**(1/2) - ((lineseg[0][0] - vertex_pair[1][0])**2 + (lineseg[0][1] - vertex_pair[1][1])**2)**(1/2)
    endpt_dist_diff2 = ((lineseg[1][0] - vertex_pair[0][0])**2 + (lineseg[1][1] - vertex_pair[0][1])**2)**(1/2) - ((lineseg[1][0] - vertex_pair[1][0])**2 + (lineseg[1][1] - vertex_pair[1][1])**2)**(1/2)
    if endpt_dist_diff1*endpt_dist_diff2 > toler:
        d = -1
        return (result, d)
    else:
        coefx1 = vertex_pair[0][1] - vertex_pair[1][1]
        coefy1 = vertex_pair[0][0] - vertex_pair[1][0]
        const1 = (vertex_pair[1][0] - vertex_pair[0][0])*(-(vertex_pair[0][1] + vertex_pair[1][1])/2) - (vertex_pair[1][1] - vertex_pair[0][1])*((vertex_pair[0][0] + vertex_pair[1][0])/2)
        coefx2 = lineseg[1][1] - lineseg[0][1]
        coefy2 = lineseg[0][0] - lineseg[1][0]
        const2 = (lineseg[1][0] - lineseg[0][0])*(-(lineseg[0][1] + lineseg[1][1])/2) + (lineseg[1][1] - lineseg[0][1])*((lineseg[0][0] + lineseg[1][0])/2)
        a = np.array([[coefx1,coefy1],[coefx2,coefy2]])
        b = np.array([const1,const2])
        result = np.linalg.solve(a,b)
        d = ((result[0] - vertex_pair[0][0])**2 + (result[1] - vertex_pair[0][1])**2)**(1/2)
        return (result, d)

def bisect_line_segment(vertex_pair = np.array([[3,3], [6, 0]]), lineseg = np.array([[3,6], [3, 4]])):
    toler = 1e-8
    result = np.double([0,0])
    vx1 = vertex_pair[0][0]
    vx2 = vertex_pair[1][0]
    vy1 = vertex_pair[0][1]
    vy2 = vertex_pair[1][1]
    lx1 = lineseg[0][0]
    lx2 = lineseg[1][0]
    ly1 = lineseg[0][1]
    ly2 = lineseg[1][1]
    if vx1 - vx2 >= toler:
        temp = vx1
        vx1 = vx2
        vx2 = temp
        temp = vy1
        vy1 = vy2
        vy2 = temp
    if lx1 - lx2 >= toler:
        temp = lx1
        lx1 = lx2
        lx2 = temp
        temp = ly1
        ly1 = ly2
        ly2 = temp      
    d = 0
    endpt_dist_diff1 = ((lx1 - vx1)**2 + (ly1 - vy1)**2)**(1/2) - ((lx1 - vx2)**2 + (ly1 - vy2)**2)**(1/2)
    endpt_dist_diff2 = ((lx2 - vx1)**2 + (ly2 - vy1)**2)**(1/2) - ((lx2 - vx2)**2 + (ly2 - vy2)**2)**(1/2)
    if endpt_dist_diff1*endpt_dist_diff2 > toler:
        d = -1
        return (result, d)
    else:
        coefx2 = ly2 - ly1
        coefy2 = lx1 - lx2
        const2 = lx1*ly2 - lx2*ly1
        coefx1 = vx1 - vx2
        coefy1 = vy1 - vy2
        const1 = (vx1-vx2)*(vx1+vx2)/2 + (vy1-vy2)*(vy1+vy2)/2
        a = np.array([[coefx1,coefy1],[coefx2,coefy2]])
        b = np.array([const1,const2])
        result = np.linalg.solve(a,b)
        d = ((result[0] - vx1)**2 + (result[1] - vy1)**2)**(1/2)
        return (result, d)

def distance_two_points(p1, p2):
    distp1p2 = np.linalg.norm(p1 - p2)
    return distp1p2

# These are the helper functions added to rev1
# Two points bisector intersect a line
def bisect_line(vertex_pair = np.array([[3,3], [6, 0]]), lineseg = np.array([[3,6], [3, 4]])): 
    toler = 1e-8
    result = np.double([0,0])
    vx1 = vertex_pair[0][0]
    vx2 = vertex_pair[1][0]
    vy1 = vertex_pair[0][1]
    vy2 = vertex_pair[1][1]
    lx1 = lineseg[0][0]
    lx2 = lineseg[1][0]
    ly1 = lineseg[0][1]
    ly2 = lineseg[1][1]
    if vx1 - vx2 >= toler:
        temp = vx1
        vx1 = vx2
        vx2 = temp
        temp = vy1
        vy1 = vy2
        vy2 = temp
    if lx1 - lx2 >= toler:
        temp = lx1
        lx1 = lx2
        lx2 = temp
        temp = ly1
        ly1 = ly2
        ly2 = temp      

    coefx2 = ly2 - ly1
    coefy2 = lx1 - lx2
    const2 = lx1*ly2 - lx2*ly1
    coefx1 = vx1 - vx2
    coefy1 = vy1 - vy2
    const1 = (vx1-vx2)*(vx1+vx2)/2 + (vy1-vy2)*(vy1+vy2)/2
    a = np.array([[coefx1,coefy1],[coefx2,coefy2]])
    b = np.array([const1,const2])
    result = np.linalg.solve(a,b)
    d = ((result[0] - vx1)**2 + (result[1] - vy1)**2)**(1/2)
    return (result, d)

# Given a line (two points) and the x-coordinate of a point on the line, find its y coordinate
def find_y_on_line(line, x):
    x1 = line[0][0]
    y1 = line[0][1]
    x2 = line[1][0]
    y2 = line[1][1]
    if(np.abs(x - x1) > np.abs(x - x2)):
        return((x-x1)*(y2-y1)/(x2-x1) + y1)
    else:
        return((x-x2)*(y1-y2)/(x1-x2) + y2)
# Given a line (two points) and the y-coordinate of a point on the line, find its x coordinate
def find_x_on_line(line, y):
    x1 = line[0][0]
    y1 = line[0][1]
    x2 = line[1][0]
    y2 = line[1][1]
    if(np.abs(y - y1) > np.abs(y - y2)):
        return((y-y1)*(x2-x1)/(y2-y1) + x1)
    else:
        return((y-y2)*(x1-x2)/(y1-y2) + x2)

# Find the distance from a point to a line (defined by two points)
def dist_point_to_line(point, line):
    x0 = point[0]
    y0 = point[1]
    x1 = line[0,0]
    y1 = line[0,1]
    x2 = line[1,0]
    y2 = line[1,1]
    return(np.abs((x2 - x1)*(y1-y0) - (x1-x0)*(y2-y1))/np.sqrt((x2 - x1)**2 + (y2 - y1)**2))

# Find the projection point of a point onto a line
def proj_point_to_line(point, lineseg):
    result = np.double([0,0])
    vx_lineseg = lineseg[1][0] - lineseg[0][0]
    vy_lineseg = lineseg[1][1] - lineseg[0][1]
    vx_point = point[0] - lineseg[0][0]
    vy_point = point[1] - lineseg[0][1]
    point_dot_lineseg = vx_point*vx_lineseg + vy_point*vy_lineseg
    lineseg_dot_lineseg = vx_lineseg*vx_lineseg + vy_lineseg*vy_lineseg
    l = point_dot_lineseg/lineseg_dot_lineseg
    result[0] = lineseg[0][0] + l*vx_lineseg
    result[1] = lineseg[0][1] + l*vy_lineseg        
    return result

def get_far_point(line, alpha=10):
    return(alpha*line[0,:] + (1-alpha)*line[1,:])

# Given n pivots and a line, find the smallest circle enclusing all pivot points with the circle center lying on the line
# The line is represented by two points on it
# seg = 0 line, = 1 find and project, = 2 early termination
# early = 1 to stop and project as soon as x* (or y*) is determined to be on a half line that does not cover the_line
def Megiddo(pivots, the_line, verbose = 0, seg = 1, early = 0):
    toler = 1e-10
    n_distance_two_points_calls = 0
    n_project_point_to_line_segment_calls = 0
    n_bisect_line_segment_calls = 0
    n_dist_point_to_line_calls = 0
    original_pivots = np.copy(pivots)  # Save a copy of the original before elimination
    the_end_indx = -1  # initialize
    if np.abs(the_line[0,0] - the_line[1,0]) > np.abs(the_line[0,1] - the_line[1,1]):
        while len(pivots) > 0:
            indx_to_discard = np.empty(0, dtype=int)
            n_pairs = len(pivots) // 2
            odd = len(pivots) % 2
            crits = np.empty((0,2))
            crits_pivots_indx = np.empty((0,2), dtype=int) # the point whose projx is smaller goes first
            for i in range(n_pairs):
                proj0 = proj_point_to_line(pivots[2*i,], the_line)
                proj1 = proj_point_to_line(pivots[2*i+1,], the_line)
                n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 2
                if np.abs(proj0[0] - proj1[0]) < toler:
                    d0 = dist_point_to_line(pivots[2*i,], the_line)
                    d1 = dist_point_to_line(pivots[2*i+1,], the_line)
                    n_dist_point_to_line_calls = n_dist_point_to_line_calls + 2
                    if d0 < d1:
                        indx_to_discard = np.append(indx_to_discard, 2*i)
                    else:
                        indx_to_discard = np.append(indx_to_discard, 2*i+1)
                else:
                    this_crit,_ = bisect_line(pivots[2*i:(2*i+2),], the_line)
                    n_bisect_line_segment_calls = n_bisect_line_segment_calls + 1
                    crits = np.append(crits, np.reshape(this_crit, (1,2)), axis=0)
                    if proj0[0] < proj1[0]:
                        crits_pivots_indx = np.append(crits_pivots_indx, np.array([[2*i, 2*i+1]]), axis = 0)
                    else:
                        crits_pivots_indx = np.append(crits_pivots_indx, np.array([[2*i+1, 2*i]]), axis = 0)
            
            if odd == 1:
                if n_pairs > 0:
                    proj0 = proj_point_to_line(pivots[2*n_pairs,], the_line)
                    proj1 = proj_point_to_line(pivots[0,], the_line)
                    n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 2
                    if np.abs(proj0[0] - proj1[0]) < toler:
                        d0 = dist_point_to_line(pivots[2*n_pairs,], the_line)
                        d1 = dist_point_to_line(pivots[0,], the_line)
                        n_dist_point_to_line_calls = n_dist_point_to_line_calls + 2
                        if d0 < d1:
                            indx_to_discard = np.append(indx_to_discard, 2*n_pairs)
                        else:
                            indx_to_discard = np.append(indx_to_discard, 0)
                    else:
                        this_crit,_ = bisect_line(np.array([pivots[2*n_pairs,],pivots[0,]]), the_line)
                        n_bisect_line_segment_calls = n_bisect_line_segment_calls + 1
                        crits = np.append(crits, np.reshape(this_crit, (1,2)), axis=0)
                        if proj0[0] < proj1[0]:
                            crits_pivots_indx = np.append(crits_pivots_indx, np.array([[2*n_pairs, 0]]), axis = 0)
                        else:
                            crits_pivots_indx = np.append(crits_pivots_indx, np.array([[0, 2*n_pairs]]), axis = 0)
                else:
                    # only a single pivot left, its projection on the line will be the solution
                    proj = proj_point_to_line(pivots[0,], the_line)
                    n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
                    if seg == 0:
                        # Find the cover radius: must check for all original pivots
                        cover_radius = distance_two_points(proj, pivots[0,])
                        n_distance_two_points_calls = n_distance_two_points_calls + 1

                        stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                                 "n_dist_point_to_line_calls":n_dist_point_to_line_calls}
                        return(proj, cover_radius, stats)
                    else:
                        proj = project_point_to_line_segment(proj, the_line)
                        n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
                        cover_radius = 0
                        for i in range(len(original_pivots)):
                            this_dist = distance_two_points(proj, original_pivots[i,:])
                            n_distance_two_points_calls = n_distance_two_points_calls + 1
                            if this_dist > cover_radius:
                                cover_radius = this_dist
                        stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                                 "n_dist_point_to_line_calls":n_dist_point_to_line_calls}
                        return(proj, cover_radius, stats)
            if crits.shape[0] != 0:
                if crits.shape[0] % 2 == 0:
                    xmin_indx = np.argmin(crits[:,0])
                    remaining_indx = np.concatenate((np.arange(xmin_indx), np.arange(xmin_indx+1,crits.shape[0])))
                    xmedian = np.median(crits[remaining_indx,0])
                else:
                    xmedian = np.median(crits[:,0])
                ymedian = find_y_on_line(the_line, xmedian)
                # compute g(xm) and find I
                gxm = 0 
                Iset = []
                medianpoint = np.array([xmedian, ymedian])
                for i in range(len(pivots)):
                    this_one = distance_two_points(medianpoint, pivots[i,:])
                    n_distance_two_points_calls = n_distance_two_points_calls + 1
                    if this_one - gxm > -toler:
                        if this_one - gxm > toler:
                            Iset.clear()
                        gxm = this_one
                        Iset.append(i)
                # decide
                proj_Iset = np.empty((0,2))
                for i in Iset:
                    proj_Iset = np.append(proj_Iset, np.reshape(proj_point_to_line(pivots[i,], the_line), (1,2)), axis=0)
                    n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
                if np.all([xmedian < proj_Iset[i,0]-toler for i in range(len(Iset))]):
                    # xm < x*, then for each pair whose crit is < xm, discard the point whose projx is greater
                    if early == 1:
                        if xmedian > np.max(the_line[:,0]):
                            the_end_indx = np.argmax(the_line[:,0])
                            break
                    for i in range(crits.shape[0]):
                        if crits[i,0] <= xmedian:
                            indx_to_discard = np.append(indx_to_discard, crits_pivots_indx[i,1])              
                elif np.all([xmedian > proj_Iset[i,0]+toler for i in range(len(Iset))]):
                    # xm > x*, then for each pair whose crit is > xm, discard the point whose projx is smaller
                    if early == 1:
                        if xmedian < np.min(the_line[:,0]):
                            the_end_indx = np.argmin(the_line[:,0])
                            break
                    for i in range(crits.shape[0]):
                        if crits[i,0] >= xmedian:
                            indx_to_discard = np.append(indx_to_discard, crits_pivots_indx[i,0])
                else:                        
                    if seg == 0:
                        # Find the cover radius
                        cover_radius = 0
                        for i in Iset:
                            this_dist = distance_two_points([xmedian,ymedian], pivots[i,:])
                            n_distance_two_points_calls = n_distance_two_points_calls + 1
                            if this_dist > cover_radius:
                                cover_radius = this_dist
                        stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                                 "n_dist_point_to_line_calls":n_dist_point_to_line_calls}
                        return(np.array([xmedian, ymedian]), cover_radius, stats)
                    elif seg == 1:
                        proj = project_point_to_line_segment([xmedian, ymedian], the_line)
                        n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
                        # Find the cover radius: must check for all original pivots
                        cover_radius = 0
                        for i in range(len(original_pivots)):
                            this_dist = distance_two_points(proj, original_pivots[i,:])
                            n_distance_two_points_calls = n_distance_two_points_calls + 1
                            if this_dist > cover_radius:
                                cover_radius = this_dist
                        stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                                 "n_dist_point_to_line_calls":n_dist_point_to_line_calls}
                        return(proj, cover_radius, stats)
                if verbose == 1:
                    plt.figure(figsize=(8, 8))
                    plt.axis('scaled')
                    plt.xlim((xmin-pmar,xmax+pmar))
                    plt.ylim((ymin-pmar,ymax+pmar))
                    plt.plot(pivots[:,0], pivots[:,1], 'o')
                    for i in range(len(pivots)):
                        plt.text(pivots[i,0], pivots[i,1], str(i), fontsize='x-large')
                    far1 = get_far_point(the_line, alpha=300)
                    far2 = get_far_point(the_line, alpha=-300)
                    far_points = np.concatenate((far1, far2), axis=0)
                    far_points = np.reshape(far_points, (2,2))
                    plt.plot(far_points[:,0], far_points[:,1], 'b--')
                    plt.plot(the_line[:,0], the_line[:,1], 'r-')
                    plt.plot(crits[:,0], crits[:,1], 'ro')
                    plt.plot(xmedian, ymedian, 'g^', markersize = 8)
                    plt.plot(pivots[indx_to_discard,0], pivots[indx_to_discard,1], 'gx', markersize = 12, color = 'red')
            # Update pivots
            if len(indx_to_discard) > 0:
                pivots = np.delete(pivots, indx_to_discard, axis=0)
            else:
                if len(pivots) >= 3:
                    # shuffle indices
                    pivots = np.random.permutation(pivots)
                else:
                    # the solution is the projection point of one of the two pivots
                    d0 = dist_point_to_line(pivots[0,], the_line)
                    d1 = dist_point_to_line(pivots[1,], the_line)
                    n_dist_point_to_line_calls = n_dist_point_to_line_calls + 2
                    if d0 < d1:
                        proj = proj1
                    else:
                        proj = proj0
                    if seg == 1:
                        proj = project_point_to_line_segment(proj, the_line)
                        n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
                    # Find the cover radius: must check for all original pivots
                    cover_radius = 0
                    for i in range(len(original_pivots)):
                        this_dist = distance_two_points(proj, original_pivots[i,:])
                        n_distance_two_points_calls = n_distance_two_points_calls + 1
                        if this_dist > cover_radius:
                            cover_radius = this_dist
                    stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                             "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                             "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                             "n_dist_point_to_line_calls":n_dist_point_to_line_calls}
                    return(proj, cover_radius, stats)
            if verbose == 1:
                print(pivots)
    else:
        while len(pivots) > 0:
            indx_to_discard = np.empty(0, dtype=int)
            n_pairs = len(pivots) // 2
            odd = len(pivots) % 2
            crits = np.empty((0,2))
            crits_pivots_indx = np.empty((0,2), dtype=int) # the point whose projy is smaller goes first
            for i in range(n_pairs):
                proj0 = proj_point_to_line(pivots[2*i,], the_line)
                proj1 = proj_point_to_line(pivots[2*i+1,], the_line)
                n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 2
                if np.abs(proj0[1] - proj1[1]) < toler:
                    d0 = dist_point_to_line(pivots[2*i,], the_line)
                    d1 = dist_point_to_line(pivots[2*i+1,], the_line)
                    n_dist_point_to_line_calls = n_dist_point_to_line_calls + 2
                    if d0 < d1:
                        indx_to_discard = np.append(indx_to_discard, 2*i)
                    else:
                        indx_to_discard = np.append(indx_to_discard, 2*i+1)
                else:
                    this_crit,_ = bisect_line(pivots[2*i:(2*i+2),], the_line)
                    n_bisect_line_segment_calls = n_bisect_line_segment_calls + 1
                    crits = np.append(crits, np.reshape(this_crit, (1,2)), axis=0)
                    if proj0[1] < proj1[1]:
                        crits_pivots_indx = np.append(crits_pivots_indx, np.array([[2*i, 2*i+1]]), axis = 0)
                    else:
                        crits_pivots_indx = np.append(crits_pivots_indx, np.array([[2*i+1, 2*i]]), axis = 0)
            
            if odd == 1:
                if n_pairs > 0:
                    proj0 = proj_point_to_line(pivots[2*n_pairs,], the_line)
                    proj1 = proj_point_to_line(pivots[0,], the_line)
                    n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 2
                    if np.abs(proj0[1] - proj1[1]) < toler:
                        d0 = dist_point_to_line(pivots[2*n_pairs,], the_line)
                        d1 = dist_point_to_line(pivots[0,], the_line)
                        n_dist_point_to_line_calls = n_dist_point_to_line_calls + 2
                        if d0 < d1:
                            indx_to_discard = np.append(indx_to_discard, 2*n_pairs)
                        else:
                            indx_to_discard = np.append(indx_to_discard, 0)
                    else:
                        this_crit,_ = bisect_line(np.array([pivots[2*n_pairs,],pivots[0,]]), the_line)
                        n_bisect_line_segment_calls = n_bisect_line_segment_calls + 1
                        crits = np.append(crits, np.reshape(this_crit, (1,2)), axis=0)
                        if proj0[1] < proj1[1]:
                            crits_pivots_indx = np.append(crits_pivots_indx, np.array([[2*n_pairs, 0]]), axis = 0)
                        else:
                            crits_pivots_indx = np.append(crits_pivots_indx, np.array([[0, 2*n_pairs]]), axis = 0)
                else:
                    # only a single pivot left, its projection on the line will be the solution
                    proj = proj_point_to_line(pivots[0,], the_line)
                    n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
                    if seg == 0:
                        # Find the cover radius: must check for all original pivots
                        cover_radius = distance_two_points(proj, pivots[0,])
                        n_distance_two_points_calls = n_distance_two_points_calls + 1

                        stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                                 "n_dist_point_to_line_calls":n_dist_point_to_line_calls}
                        return(proj, cover_radius, stats)
                    else:
                        proj = project_point_to_line_segment(proj, the_line)
                        n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
                        cover_radius = 0
                        for i in range(len(original_pivots)):
                            this_dist = distance_two_points(proj, original_pivots[i,:])
                            n_distance_two_points_calls = n_distance_two_points_calls + 1
                            if this_dist > cover_radius:
                                cover_radius = this_dist
                        stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                                 "n_dist_point_to_line_calls":n_dist_point_to_line_calls}
                        return(proj, cover_radius, stats)
            if crits.shape[0] != 0:
                if crits.shape[0] % 2 == 0:
                    ymin_indx = np.argmin(crits[:,1])
                    remaining_indx = np.concatenate((np.arange(ymin_indx), np.arange(ymin_indx+1,crits.shape[0])))
                    ymedian = np.median(crits[remaining_indx,1])
                else:
                    ymedian = np.median(crits[:,1])
                xmedian = find_x_on_line(the_line, ymedian)
                # compute g(xm) and find I
                gxm = 0 
                Iset = []
                medianpoint = np.array([xmedian, ymedian])
                for i in range(len(pivots)):
                    this_one = distance_two_points(medianpoint, pivots[i,:])
                    n_distance_two_points_calls = n_distance_two_points_calls + 1
                    if this_one - gxm > -toler:
                        if this_one - gxm > toler:
                            Iset.clear()
                        gxm = this_one
                        Iset.append(i)
                # decide
                proj_Iset = np.empty((0,2))
                for i in Iset:
                    proj_Iset = np.append(proj_Iset, np.reshape(proj_point_to_line(pivots[i,], the_line), (1,2)), axis=0)
                    n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
                if np.all([ymedian < proj_Iset[i,1]-toler for i in range(len(Iset))]):
                    # ym < y*, then for each pair whose crit is < ym, discard the point whose projy is greater
                    if early == 1:
                        if ymedian > np.max(the_line[:,1]):
                            the_end_indx = np.argmax(the_line[:,1])
                            break
                    for i in range(crits.shape[0]):
                        if crits[i,1] <= ymedian:
                            indx_to_discard = np.append(indx_to_discard, crits_pivots_indx[i,1])              
                elif np.all([ymedian > proj_Iset[i,1]+toler for i in range(len(Iset))]):
                    # ym > y*, then for each pair whose crit is > ym, discard the point whose projy is smaller
                    if early == 1:
                        if ymedian < np.min(the_line[:,1]):
                            the_end_indx = np.argmin(the_line[:,1])
                            break
                    for i in range(crits.shape[0]):
                        if crits[i,1] >= ymedian:
                            indx_to_discard = np.append(indx_to_discard, crits_pivots_indx[i,0])
                else:
                    if seg == 0:
                        # Find the cover radius
                        cover_radius = 0
                        for i in Iset:
                            this_dist = distance_two_points([xmedian,ymedian], pivots[i,:])
                            n_distance_two_points_calls = n_distance_two_points_calls + 1
                            if this_dist > cover_radius:
                                cover_radius = this_dist
                        stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                                 "n_dist_point_to_line_calls":n_dist_point_to_line_calls}
                        return(np.array([xmedian, ymedian]), cover_radius, stats)
                    elif seg == 1:
                        proj = project_point_to_line_segment([xmedian, ymedian], the_line)
                        n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
                        # Find the cover radius: must check for all original pivots
                        cover_radius = 0
                        for i in range(len(original_pivots)):
                            this_dist = distance_two_points(proj, original_pivots[i,:])
                            n_distance_two_points_calls = n_distance_two_points_calls + 1
                            if this_dist > cover_radius:
                                cover_radius = this_dist
                        stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                                 "n_dist_point_to_line_calls":n_dist_point_to_line_calls}
                        return(proj, cover_radius, stats)
            if verbose == 1:
                plt.figure(figsize=(8, 8))
                plt.axis('scaled')
                plt.xlim((xmin-pmar,xmax+pmar))
                plt.ylim((ymin-pmar,ymax+pmar))
                plt.plot(pivots[:,0], pivots[:,1], 'o')
                for i in range(len(pivots)):
                    plt.text(pivots[i,0], pivots[i,1], str(i), fontsize='x-large')
                far1 = get_far_point(the_line, alpha=300)
                far2 = get_far_point(the_line, alpha=-300)
                far_points = np.concatenate((far1, far2), axis=0)
                far_points = np.reshape(far_points, (2,2))
                plt.plot(far_points[:,0], far_points[:,1], 'b--')
                plt.plot(the_line[:,0], the_line[:,1], 'r-')
                plt.plot(crits[:,0], crits[:,1], 'ro')
                plt.plot(xmedian, ymedian, 'g^', markersize = 8)
                plt.plot(pivots[indx_to_discard,0], pivots[indx_to_discard,1], 'gx', markersize = 12, color = 'red')
            # Update pivots
            if len(indx_to_discard) > 0:
                pivots = np.delete(pivots, indx_to_discard, axis=0)
            else:
                if len(pivots) >= 3:
                    # shuffle indices
                    pivots = np.random.permutation(pivots)
                else:
                    # the solution is the projection point of one of the two pivots
                    d0 = dist_point_to_line(pivots[0,], the_line)
                    d1 = dist_point_to_line(pivots[1,], the_line)
                    n_dist_point_to_line_calls = n_dist_point_to_line_calls + 2
                    if d0 < d1:
                        proj = proj1
                    else:
                        proj = proj0
                    if seg == 1:
                        proj = project_point_to_line_segment(proj, the_line)
                        n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
                    # Find the cover radius: must check for all original pivots
                    cover_radius = 0
                    for i in range(len(original_pivots)):
                        this_dist = distance_two_points(proj, original_pivots[i,:])
                        n_distance_two_points_calls = n_distance_two_points_calls + 1
                        if this_dist > cover_radius:
                            cover_radius = this_dist
                    stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                             "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                             "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                             "n_dist_point_to_line_calls":n_dist_point_to_line_calls}
                    return(proj, cover_radius, stats)
            if verbose == 1:
                print(pivots)
    if early == 1 and the_end_indx >=0:
        # return the early termination solution
        # Find the cover radius: must check for all original pivots
        proj = the_line[the_end_indx,]
        cover_radius = 0
        for i in range(len(original_pivots)):
            this_dist = distance_two_points(proj, original_pivots[i,:])
            n_distance_two_points_calls = n_distance_two_points_calls + 1
            if this_dist > cover_radius:
                cover_radius = this_dist
        stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                 "n_dist_point_to_line_calls":n_dist_point_to_line_calls}
        return(proj, cover_radius, stats)
    else:
        print("Something is wrong")
        return(np.array([0,0]), 0, {})


# Given all pivot points in a Voronoi cell, the MCC radius and all boundary line segments of the overall feasible region, find the CMCC. Wei et al (2006)
def Wei2006(pivots, MCCradius):
    toler = 1e-8
    n_distance_two_points_calls = 0
    n_project_point_to_line_segment_calls = 0
    n_bisect_line_segment_calls = 0
    best_cmcc_center = np.empty((0,2))
    best_cmcc_radius = 10000
    hull = ConvexHull(pivots)
    # Evaluate all vertices of the convex hull
    # For each vertex, find its closest point on each line segment of the boundary
    for i in hull.vertices:
        # outer boundary
        for this_edge in range(len(edges)):
            projected_point = project_point_to_line_segment(pivots[i], corners[edges[this_edge]])
            n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
            this_dist = distance_two_points(projected_point, pivots[i])
            n_distance_two_points_calls = n_distance_two_points_calls + 1
            if this_dist - MCCradius >= toler and this_dist - best_cmcc_radius <= -toler:
                # Test if the circle centered at project_point with radius this_dist can cover the hull
                cover_hull = True
                for j in hull.vertices:
                    dist_j = distance_two_points(pivots[j], projected_point)
                    n_distance_two_points_calls = n_distance_two_points_calls + 1
                    if dist_j - this_dist >= toler:
                        cover_hull = False
                        break
                if cover_hull == True:
                    best_cmcc_radius = this_dist
                    best_cmcc_center = np.copy(projected_point)
                    #cmcc_candidates.append((projected_point, this_dist))
        # hole boundaries
        for this_hole in hole_file_names:
            this_hole_corners = holes[this_hole]
            for this_edge in holes_edges[this_hole]:
                projected_point = project_point_to_line_segment(pivots[i], this_hole_corners[this_edge])
                n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
                this_dist = distance_two_points(projected_point, pivots[i])
                n_distance_two_points_calls = n_distance_two_points_calls + 1
                if this_dist - MCCradius >= toler and this_dist - best_cmcc_radius <= -toler:
                    # Test if the circle centered at project_point with radius this_dist can cover the hull
                    cover_hull = True
                    for j in hull.vertices:
                        dist_j = distance_two_points(pivots[j], projected_point)
                        n_distance_two_points_calls = n_distance_two_points_calls + 1
                        if dist_j - this_dist >= toler:
                            cover_hull = False
                            break
                    if cover_hull == True:
                        best_cmcc_radius = this_dist
                        best_cmcc_center = np.copy(projected_point)
    # Evaluate all pairs of vertices of the convex hull
    for i in range(len(hull.vertices) - 1):
        for j in range(i + 1, len(hull.vertices)):
            vi = hull.vertices[i]
            vj = hull.vertices[j]
            vertex_pair = pivots[[vi,vj],]
            # outer boundary
            for this_edge in range(len(edges)):
                (intersect_point, this_dist) = bisect_line_segment(vertex_pair, corners[edges[this_edge]])
                n_bisect_line_segment_calls = n_bisect_line_segment_calls + 1
                if this_dist <= -toler:
                    continue
                if this_dist - MCCradius >= toler and this_dist - best_cmcc_radius <= -toler:
                    # Test if the circle centered at project_point with radius this_dist can cover the hull
                    cover_hull = True
                    for j1 in hull.vertices:
                        dist_j = distance_two_points(pivots[j1], intersect_point)
                        n_distance_two_points_calls = n_distance_two_points_calls + 1
                        if dist_j - this_dist >= toler:
                            cover_hull = False
                            break
                    if cover_hull == True:
                        best_cmcc_radius = this_dist
                        best_cmcc_center = np.copy(intersect_point)
            # hole boundaries
            for this_hole in hole_file_names:
                this_hole_corners = holes[this_hole]
                for this_edge in holes_edges[this_hole]:
                    (intersect_point, this_dist) = bisect_line_segment(vertex_pair, this_hole_corners[this_edge])
                    n_bisect_line_segment_calls = n_bisect_line_segment_calls + 1
                    if this_dist <= -toler:
                        continue
                    if this_dist - MCCradius >= toler and this_dist - best_cmcc_radius <= -toler:
                        # Test if the circle centered at project_point with radius this_dist can cover the hull
                        cover_hull = True
                        for j1 in hull.vertices:
                            dist_j = distance_two_points(pivots[j1], intersect_point)
                            n_distance_two_points_calls = n_distance_two_points_calls + 1
                            if dist_j - this_dist >= toler:
                                cover_hull = False
                                break
                        if cover_hull == True:
                            best_cmcc_radius = this_dist
                            best_cmcc_center = np.copy(intersect_point)
    run_stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls}
    return (best_cmcc_center, best_cmcc_radius, run_stats)

# Improved with preprocessing: knowing in which hole the infeasible center lies is tremendously helpful
def Wei2006_v2(pivots, MCCradius, the_hole, verbose = 0):
    toler = 1e-8
    n_distance_two_points_calls = 0
    n_project_point_to_line_segment_calls = 0
    n_bisect_line_segment_calls = 0
    best_cmcc_center = np.empty((0,2))
    best_cmcc_radius = 10000
    if the_hole == 'polygon':
        the_edges = edges
        the_vertices = corners
    else:
        the_edges = holes_edges[the_hole]
        the_vertices = holes[the_hole]
    hull = ConvexHull(pivots)
    # Evaluate all vertices of the convex hull
    # For each vertex, find its closest point on each line segment of the boundary
    for i in hull.vertices:
        # outer boundary
        for this_edge in range(len(the_edges)):
            projected_point = project_point_to_line_segment(pivots[i], the_vertices[the_edges[this_edge]])
            n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
            this_dist = distance_two_points(projected_point, pivots[i])
            n_distance_two_points_calls = n_distance_two_points_calls + 1
            if this_dist - MCCradius >= toler and this_dist - best_cmcc_radius <= -toler:
                # Test if the circle centered at project_point with radius this_dist can cover the hull
                cover_hull = True
                for j in hull.vertices:
                    dist_j = distance_two_points(pivots[j], projected_point)
                    n_distance_two_points_calls = n_distance_two_points_calls + 1
                    if dist_j - this_dist >= toler:
                        cover_hull = False
                        break
                if cover_hull == True:
                    best_cmcc_radius = this_dist
                    best_cmcc_center = np.copy(projected_point)
    # Evaluate all pairs of vertices of the convex hull
    for i in range(len(hull.vertices) - 1):
        for j in range(i + 1, len(hull.vertices)):
            vi = hull.vertices[i]
            vj = hull.vertices[j]
            vertex_pair = pivots[[vi,vj],]
            # outer boundary
            for this_edge in range(len(the_edges)):
                (intersect_point, this_dist) = bisect_line_segment(vertex_pair, the_vertices[the_edges[this_edge]])
                n_bisect_line_segment_calls = n_bisect_line_segment_calls + 1
                if this_dist <= -toler:
                    continue
                if this_dist - MCCradius >= toler and this_dist - best_cmcc_radius <= -toler:
                    # Test if the circle centered at project_point with radius this_dist can cover the hull
                    cover_hull = True
                    for j1 in hull.vertices:
                        dist_j = distance_two_points(pivots[j1], intersect_point)
                        n_distance_two_points_calls = n_distance_two_points_calls + 1
                        if dist_j - this_dist >= toler:
                            cover_hull = False
                            break
                    if cover_hull == True:
                        best_cmcc_radius = this_dist
                        best_cmcc_center = np.copy(intersect_point)
    run_stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls}
    if verbose >= 1:
        print("Best_cover_radius returned:" + str(best_cmcc_radius))
    return (best_cmcc_center, best_cmcc_radius, run_stats)



def Liu2020(pivots, MCCcenter, MCCradius, the_hole, verbose = 0):
    toler = 1e-8  # toler must be a small number strictly greater than 0
    n_distance_two_points_calls = 0
    n_project_point_to_line_segment_calls = 0
    n_bisect_line_segment_calls = 0
    n_edges_skipped = 0  # initial line segments removed due to distance
    n_found_by_1 = 0
    n_list_truncations = 0
    n_edges_truncated = 0
    n_prune_by_ub_1_point = 0
    n_found_by_2 = 0
    n_vertex_pairs_skipped = 0
    n_prune_by_ub_2_point = 0
    n_prune_by_lb = 0
    # only take the pivots that lie on the convex hull of all the pivots
    hull = ConvexHull(pivots)
    pivots = pivots[hull.vertices]  # keep only the pivots that define the convex hull
    if verbose >= 1:
        print("Infeasible region: " + the_hole)
    if the_hole == 'polygon':
        the_edges = edges
        the_vertices = corners
    else:
        the_edges = holes_edges[the_hole]
        the_vertices = holes[the_hole]
    n_edges = len(the_edges)
    d = {}  # distance from the current MCC center to each boundary line segment
    for i in range(n_edges):
        projected_point = project_point_to_line_segment(MCCcenter, the_vertices[the_edges[i]])
        n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
        projected_dist = distance_two_points(projected_point, MCCcenter)
        n_distance_two_points_calls = n_distance_two_points_calls + 1
        
        if projected_dist - MCCradius >= toler:
            if verbose >=2:
                print("The line segment is more than MCCradius away from the MCCcenter, eliminate it")
            n_edges_skipped = n_edges_skipped + 1
            continue
        
        d.update({i:projected_dist})
    sorted_list_d = sorted(d.items(), key = itemgetter(1))  # sorted list of (key, value) pairs of d, in increasing order of value
    if verbose >= 1:
        print("Skipped " + str(n_edges_skipped) + " edges out of " + str(n_edges) + " edges of the hole (or outer polygon)")
        print("Initial # of line segments in the list: " + str(len(sorted_list_d)))
    # Iterate the sorted list
    best_cover_center = np.empty(2)
    best_cover_radius = 100000
    di = 0  # index of the sorted_list_d
    while True:
        print("{:d}  {:.8f}  [{:.8f}, {:.8f}]".format(di, best_cover_radius, best_cover_center[0], best_cover_center[1]))
        if di >= len(sorted_list_d):  # All done
            if verbose >= 1:
                print("Number of line segments visited: " + str(di))
            break
        this_segment_index = sorted_list_d[di][0]  # the key in the (key, value) pair of the di-th entry of sorted_list_d
        the_two_vertices = the_vertices[the_edges[this_segment_index]]
        # try method 1: currently has a problem
        found_by_1 = 0
        for ei in range(2):
            # for the two vertices of the segment
            max_dist_to_segment_end = 0
            pivot_indx = 0
            for i in range(len(pivots)):
                this_dist_to_segment_end = distance_two_points(the_two_vertices[ei], pivots[i])
                n_distance_two_points_calls = n_distance_two_points_calls + 1
                if this_dist_to_segment_end - max_dist_to_segment_end >= toler:
                    max_dist_to_segment_end = this_dist_to_segment_end
                    pivot_indx = i
            pivot_project_point = project_point_to_line_segment(pivots[pivot_indx], the_two_vertices)
            n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
            if np.linalg.norm(pivot_project_point - the_two_vertices[ei]) <= toler:
                found_center = the_two_vertices[ei]
                found_radius = max_dist_to_segment_end
                if verbose >= 1:
                    print("Found by method 1, directly move to the next edge")
                found_by_1 = 1
                break
        if found_by_1 == 1:
            #if found_radius < best_cover_radius:
            if found_radius - best_cover_radius <= -toler:
                best_cover_radius = found_radius
                best_cover_center = np.copy(found_center)
                # since the global best_cover_radius is updated, we need to go over the sorted_list_d to remove any element whose d value is greater than sqrt(best_cover_radius^2 - MCCradius^2)
                len_before_truncation = len(sorted_list_d)
                sorted_list_d = [(k, v) for (k, v) in sorted_list_d if v <= np.sqrt(best_cover_radius**2 - MCCradius**2)]
                len_after_truncation = len(sorted_list_d)
                if len_after_truncation < len_before_truncation:
                    n_list_truncations = n_list_truncations + 1
                    n_edges_truncated = n_edges_truncated + len_before_truncation - len_after_truncation         
            n_found_by_1 = n_found_by_1 + 1
            di = di + 1
            continue
        
        # if cannot find by method 1, proceed to the conventional method
        # for each pivot, find its projection point and projection distance to the segment
        # the projection point can be the first segment end point 0, the second end point 1, or the interior of the segment -1
        # record the projection point type (0, 1 or -1), and record the maximum projection distance, which is a LB for the CMCC radius
        # if the CMCC has only one pivot point on it, then the pivot point must have the largest projection distance to the segment among all pivots
        # so we only need to check if that pivot (that has the largest projection distance) is the candidate for CMCC center

        max_project_dist = 0
        max_project_point = np.empty(2)
        projection_point_type = np.empty(len(pivots))
        prune_by_ub = 0
        for i in range(len(pivots)):
            this_pivot_project_point = project_point_to_line_segment(pivots[i], the_two_vertices)
            n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
            this_pivot_project_dist = distance_two_points(pivots[i], this_pivot_project_point)
            n_distance_two_points_calls = n_distance_two_points_calls + 1
            if this_pivot_project_dist - max_project_dist >= toler:
                max_project_dist = this_pivot_project_dist
                max_project_point = np.copy(this_pivot_project_point)
                if this_pivot_project_dist - best_cover_radius >= toler:
                    prune_by_ub = 1
                    break
            if np.linalg.norm(this_pivot_project_point - the_two_vertices[0]) <= toler:
                projection_point_type[i] = 0
                n_distance_two_points_calls = n_distance_two_points_calls + 1
            elif np.linalg.norm(this_pivot_project_point - the_two_vertices[1]) <= toler:
                projection_point_type[i] = 1
                n_distance_two_points_calls = n_distance_two_points_calls + 1
            else:
                projection_point_type[i] = -1
                n_distance_two_points_calls = n_distance_two_points_calls + 2
        
        if prune_by_ub == 1:
            if verbose >= 1:
                print("prune at 1-point by ub, discard this segment")
            n_prune_by_ub_1_point = n_prune_by_ub_1_point + 1
            di = di + 1
            continue
        # Does the max_project_point with max_project_dist cover all pivots?
        cover_yes = 1
        for i in range(len(pivots)):
            n_distance_two_points_calls = n_distance_two_points_calls + 1
            if distance_two_points(pivots[i], max_project_point) - max_project_dist >= toler:
                cover_yes = 0
                break
        if cover_yes == 1:  # update the best candidate, and done with this line segment. No need to check bisectors.
            if max_project_dist - best_cover_radius <= -toler:
                best_cover_radius = max_project_dist
                best_cover_center = np.copy(max_project_point)
                # since the global best_cover_radius is updated, we need to go over the sorted_list_d to remove any element whose d value is greater than sqrt(best_cover_radius^2 - MCCradius^2)
                len_before_truncation = len(sorted_list_d)
                sorted_list_d = [(k, v) for (k, v) in sorted_list_d if v <= np.sqrt(best_cover_radius**2 - MCCradius**2)]
                len_after_truncation = len(sorted_list_d)
                if len_after_truncation < len_before_truncation:
                    n_list_truncations = n_list_truncations + 1
                    n_edges_truncated = n_edges_truncated + len_before_truncation - len_after_truncation
            n_found_by_2 = n_found_by_2 + 1
 
            di = di + 1
            if verbose >= 1:
                print("skip checking vertex pairs, directly move to the next edge")
            continue  # move to the next line segment in the current sorted_list_d
            
        # Now look at pivot pairs that do not fall on same sides, i.e., no 00 or 11 pairs
        for i in range(len(pivots) - 1):
            prune_by_ub = 0
            for j in range(i + 1, len(pivots)):
                
                if (projection_point_type[i] == 0 and projection_point_type[j] == 0) or (projection_point_type[i] == 1 and projection_point_type[j] == 1):
                    #print("fall in same side: " + str(i) + " " + str(j) + " : " + str(projection_point_type[i]) + str(projection_point_type[j]))
                    n_vertex_pairs_skipped = n_vertex_pairs_skipped + 1
                    continue
                
                vertex_pair = pivots[[i,j],]
                if verbose >=3:
                    print(str(i) + " " + str(j) + " " + str(len(pivots)))
                    print(vertex_pair)
                    print(the_two_vertices)
                (intersect_point, this_dist) = bisect_line_segment(vertex_pair, the_two_vertices)
                n_bisect_line_segment_calls = n_bisect_line_segment_calls + 1
                if this_dist <= -toler:  # no intersection
                    continue
                
                if this_dist - best_cover_radius >= toler:  # the whole line segment is not hopeful, discard
                    if verbose >= 1:
                        print("prune at 2-point pair by upper bound")
                    prune_by_ub = 1
                    break               
                
                if this_dist - max_project_dist <= -toler:
                    n_prune_by_lb = n_prune_by_lb + 1
                    if verbose >= 1:
                        print("prune by lower bound")
                    continue
                
                # Now check if the intersect_point and this_dist can cover all other pivots, if yes, update best_cover_radius and update sorted_list_d
                cover_yes = 1
                for i1 in range(len(pivots)):  # must use a different iterator symbol here (cannot use i)
                    n_distance_two_points_calls = n_distance_two_points_calls + 1
                    if distance_two_points(pivots[i1], intersect_point) - this_dist >= toler:
                        cover_yes = 0
                        break
                if cover_yes == 1:  # update the best candidate, and done with this line segment. No need to check bisectors.
                    if this_dist - best_cover_radius <= -toler:
                        if verbose:
                            print(i)
                            print(j)
                            print(vertex_pair)
                        best_cover_radius = this_dist
                        best_cover_center = np.copy(intersect_point)
                        len_before_truncation = len(sorted_list_d)
                        sorted_list_d = [(k, v) for (k, v) in sorted_list_d if v <= np.sqrt(best_cover_radius**2 - MCCradius**2)]
                        len_after_truncation = len(sorted_list_d)
                        if len_after_truncation - len_before_truncation <= -toler:
                            n_list_truncations = n_list_truncations + 1
                            n_edges_truncated = n_edges_truncated + len_before_truncation - len_after_truncation
            if prune_by_ub == 1:
                n_prune_by_ub_2_point = n_prune_by_ub_2_point + 1
                break
        di = di + 1
    run_stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                 "SKP":n_edges_skipped,
                 "CL1":n_found_by_1,
                 "LTR":n_list_truncations,
                 "NTR":n_edges_truncated,
                 "UB1":n_prune_by_ub_1_point,
                 "CL2":n_found_by_2,
                 "CL4":n_vertex_pairs_skipped,
                 "UB2":n_prune_by_ub_2_point,
                 "LB1":n_prune_by_lb}
    if verbose >= 1:
        print("Best_cover_radius returned:" + str(best_cover_radius))
    return (best_cover_center, best_cover_radius, run_stats)

# Hybrid (revision 1): 2020 + 2021 with Megiddo
def Liu2021a(pivots, MCCcenter, MCCradius, the_hole, verbose = 0, early = 0):
    toler = 1e-8  # toler must be a small number strictly greater than 0
    n_distance_two_points_calls = 0
    n_project_point_to_line_segment_calls = 0
    n_bisect_line_segment_calls = 0
    n_edges_skipped = 0  # initial line segments removed due to distance
    n_found_by_1 = 0
    n_prune_by_ub_1_point = 0
    n_found_by_2 = 0
    n_edges_truncated = 0
    n_Megiddo_calls = 0
    # only take the pivots that lie on the convex hull of all the pivots
    hull = ConvexHull(pivots)
    pivots = pivots[hull.vertices]  # keep only the pivots that define the convex hull
    if verbose >= 1:
        print("Infeasible region: " + the_hole)
    if the_hole == 'polygon':
        the_edges = edges
        the_vertices = corners
    else:
        the_edges = holes_edges[the_hole]
        the_vertices = holes[the_hole]
    n_edges = len(the_edges)
    d = {}  # distance from the current MCC center to each boundary line segment
    for i in range(n_edges):
        projected_point = project_point_to_line_segment(MCCcenter, the_vertices[the_edges[i]])
        n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
        projected_dist = distance_two_points(projected_point, MCCcenter)
        n_distance_two_points_calls = n_distance_two_points_calls + 1        
        if projected_dist - MCCradius >= toler:
            if verbose >=2:
                print("The line segment is more than MCCradius away from the MCCcenter, eliminate it")
            n_edges_skipped = n_edges_skipped + 1
            continue
        d.update({i:projected_dist})
    sorted_list_d = sorted(d.items(), key = itemgetter(1))  # sorted list of (key, value) pairs of d, in increasing order of value
    if verbose >= 1:
        print("Skipped " + str(n_edges_skipped) + " edges out of " + str(n_edges) + " edges of the hole (or outer polygon)")
        print("Initial # of line segments in the list: " + str(len(sorted_list_d)))
    # Iterate the sorted list
    best_cover_center = np.empty(2)
    best_cover_radius = 100000
    di = 0  # index of the sorted_list_d
    while True:
        if di >= len(sorted_list_d):  # All done
            if verbose >= 1:
                print("Number of line segments visited: " + str(di))
            break        
        # Reviewer 1: if the current line segment is greater than sqrt(r*^2 - r^2) away from c, skip it (instead of screening the sorted_list_d list multiple times)
        if sorted_list_d[di][1] > np.sqrt(best_cover_radius**2 - MCCradius**2):
            n_edges_truncated = n_edges_truncated + 1
            di = di + 1
            continue
        
        this_segment_index = sorted_list_d[di][0]  # the key in the (key, value) pair of the di-th entry of sorted_list_d
        the_two_vertices = the_vertices[the_edges[this_segment_index]]
        # First try method 1
        found_by_1 = 0
        for ei in range(2):
            # for the two vertices of the segment
            max_dist_to_segment_end = 0
            pivot_indx = 0
            for i in range(len(pivots)):
                this_dist_to_segment_end = distance_two_points(the_two_vertices[ei], pivots[i])
                n_distance_two_points_calls = n_distance_two_points_calls + 1
                if this_dist_to_segment_end - max_dist_to_segment_end >= toler:
                    max_dist_to_segment_end = this_dist_to_segment_end
                    pivot_indx = i
            pivot_project_point = project_point_to_line_segment(pivots[pivot_indx], the_two_vertices)
            n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + 1
            if np.linalg.norm(pivot_project_point - the_two_vertices[ei]) <= toler:
                found_center = the_two_vertices[ei]
                found_radius = max_dist_to_segment_end
                if verbose >= 1:
                    print("Found by method 1, directly move to the next edge")
                found_by_1 = 1
                break
        if found_by_1 == 1:
            #if found_radius < best_cover_radius:
            if found_radius - best_cover_radius <= -toler:
                best_cover_radius = found_radius
                best_cover_center = np.copy(found_center)
            n_found_by_1 = n_found_by_1 + 1
            di = di + 1
            continue
                    
        # Use Megiddo's algorithm
        n_Megiddo_calls = n_Megiddo_calls + 1
        found_center, found_radius, Megiddo_stats = Megiddo(pivots, the_two_vertices, verbose=0, seg = 1, early = early)
        n_distance_two_points_calls = n_distance_two_points_calls + Megiddo_stats['n_distance_two_points_calls']
        n_project_point_to_line_segment_calls = n_project_point_to_line_segment_calls + Megiddo_stats['n_project_point_to_line_segment_calls']
        n_bisect_line_segment_calls = n_bisect_line_segment_calls + Megiddo_stats['n_bisect_line_segment_calls']
        #if found_radius < best_cover_radius:
        if found_radius - best_cover_radius <= -toler:
            best_cover_radius = found_radius
            best_cover_center = np.copy(found_center)
        di = di + 1
        
    run_stats = {"n_distance_two_points_calls":n_distance_two_points_calls,
                 "n_bisect_line_segment_calls":n_bisect_line_segment_calls,
                 "n_project_point_to_line_segment_calls":n_project_point_to_line_segment_calls,
                 "SKP":n_edges_skipped,
                 "CL1":n_found_by_1,
                 "LTR":n_list_truncations,
                 "NTR":n_edges_truncated,
                 "UB1":n_prune_by_ub_1_point,
                 "CL2":n_found_by_2,
                 "MGD":n_Megiddo_calls,
                 "TOT":n_edges}
    if verbose >= 1:
        print("Best_cover_radius returned:" + str(best_cover_radius))
    return (best_cover_center, best_cover_radius, run_stats)


# Start vorheur

xmax = np.max(corners[:,0])
xmin = np.min(corners[:,0])
ymax = np.max(corners[:,1])
ymin = np.min(corners[:,1])

# Global run statistics to compare Wei and Liu
total_n_distance_two_points_calls = 0
total_n_bisect_line_segment_calls = 0
total_n_project_point_to_line_segment_calls = 0
total_time_on_method = 0
total_method_calls = 0
# For Liu method only
n_edges_skipped = 0
n_found_by_1 = 0
n_list_truncations = 0
n_edges_truncated = 0
n_prune_by_ub_1_point = 0
n_found_by_2 = 0
n_vertex_pairs_skipped = 0
n_prune_by_ub_2_point = 0
n_prune_by_lb = 0
n_Megiddo_calls = 0
n_edges = 0

if read_init_points:
    points = np.load("saved_init_{:<d}.npy".format(ndepots))
    #points = np.copy(save_init_points)
else:
    # Create random points that lie inside the polygon and not inside any hole
    np.random.seed(2020 + 100*ndepots)
    points = np.empty((ndepots, 2))
    for i in range(ndepots):
        while True:
            candidate = np.around(50*np.random.random(2) + 25, decimals = 10)
            (candidate_feasible, where_candidate) = center_feasible(candidate)
            if candidate_feasible:
                break
        points[i] = candidate
    save_init_points = np.copy(points)
    np.save("saved_init_{:<d}.npy".format(ndepots), save_init_points)



plt.figure(figsize=(8, 8))
plt.axis('scaled')
plt.axis('off')
plt.xlim((xmin-pmar,xmax+pmar))
plt.ylim((ymin-pmar,ymax+pmar))
x,y = polygon.exterior.xy
plt.plot(x,y, linewidth = 1, color='blue')
for this_hole in hole_file_names:
    x,y = holes_polygon[this_hole].exterior.xy
    plt.plot(x,y, linewidth = 1)

print("ndepots: {:.0f} ".format(ndepots))
moveeps = 0.231  # Stopping criterion (10 meters)
itercnt = 0
itermax = 50
centermove = np.Inf
distmax = np.Inf
distgap = np.Inf
iter_time = 0
iterlog = np.zeros((itermax, 5))  # itercnt distmax distmin distgap centermove
centerlog = np.zeros((itermax, ndepots, 2))
dist = np.zeros(ndepots)
new_points = np.zeros((ndepots,2))
vor = Voronoi(points)
old_points = np.copy(points)
MCCfeasible = True


plt.ion()
plt.show()
with PdfPages(args['iter']+'.pdf') as pdf:
    while True:

        centerlog[itercnt] = points
        center = old_points.mean(axis=0)
        
        plt.figure(figsize=(8, 8))
        plt.axis('scaled')
        plt.xlim((xmin-pmar,xmax+pmar))
        plt.ylim((ymin-pmar,ymax+pmar))
        plt.title("Iter:"+"{:.0f}".format(itercnt) + " rmax:" + "{:.3f}".format(distmax) + " rgap:" + "{:.3f}".format(distgap) +
          " move:" + "{:.3f}".format(centermove) + " time:" + "{:.1f}".format(iter_time) + " mcc:" + str(MCCfeasible))

        x,y = polygon.exterior.xy
        plt.plot(x,y)
        for this_hole in hole_file_names:
            x,y = holes_polygon[this_hole].exterior.xy
            plt.plot(x,y)

        plt.plot(points[:, 0], points[:, 1], 'o')

        plt.plot(vor.vertices[:, 0], vor.vertices[:, 1], '*')
        for simplex in vor.ridge_vertices:
            simplex = np.asarray(simplex)
            if np.all(simplex >= 0):
                plt.plot(vor.vertices[simplex, 0], vor.vertices[simplex, 1], 'k-')
        for pointidx, simplex in zip(vor.ridge_points, vor.ridge_vertices):
            simplex = np.asarray(simplex)
            if np.any(simplex < 0):
                i = simplex[simplex >= 0][0] # finite end Voronoi vertex
                t = old_points[pointidx[1]] - old_points[pointidx[0]]  # tangent
                t = t / np.linalg.norm(t)
                n = np.array([-t[1], t[0]]) # normal
                midpoint = old_points[pointidx].mean(axis=0)
                far_point = vor.vertices[i] + np.sign(np.dot(midpoint - center, n)) * n * 1000
                plt.plot([vor.vertices[i,0], far_point[0]],[vor.vertices[i,1], far_point[1]], 'k--')

        if itercnt > 0:
            fig = plt.gcf()
            fig.set_size_inches(8,8)
            ax = fig.gca()
            for i in range(ndepots):
                circle = plt.Circle((points[i,0], points[i,1]), dist[i], color='b', fill=False)
                ax.add_artist(circle)
        pdf.savefig()
        plt.draw()
        #plt.show()
        plt.pause(0.0005)
        plt.close()
        print("Iter:"+"{:.0f}".format(itercnt) + " rmax:" + "{:.3f}".format(distmax) + " rgap:" + "{:.3f}".format(distgap) +
          " move:" + "{:.3f}".format(centermove) + " time:" + "{:.1f}".format(iter_time) + " cmcc:" + str(MCCfeasible))

        if centermove < moveeps or (itercnt+1) >= itermax:
            break

        old_points = np.copy(points)
        center = points.mean(axis=0)
        iter_time = time.time()
        if itercnt > 0:
            vor = Voronoi(points)
        itercnt = itercnt + 1
        # For each ridge
        pps = np.zeros([ndepots,1000,2])  # contains the coords of subregion (voronoi cell) border points for each depot
        ppn = np.zeros(ndepots, dtype=int)  # how many border points does the cell of each depot have
        for pointidx, simplex in zip(vor.ridge_points, vor.ridge_vertices):  # for each ridge
            simplex = np.asarray(simplex)
            if np.any(simplex < 0):  # if the ridge has an infinite end point, then caclulate a far_point to serve as the end point
                i = simplex[simplex >= 0][0] # finite end Voronoi vertex
                t = points[pointidx[1]] - points[pointidx[0]]  # tangent
                t = t / np.linalg.norm(t)
                n = np.array([-t[1], t[0]]) # normal
                midpoint = points[pointidx].mean(axis=0)
                far_point = vor.vertices[i] + np.sign(np.dot(midpoint - center, n)) * n * 1000
                # Find the intersection point of ridge and border
                # check for each area border if the ridge intersects with it
                nintsect = 0  # The finite end vertex may be inside (1) or outside (2) the polygon
                for simplex2 in edges:
                    intsect = seg_intersect(corners[simplex2[0],], corners[simplex2[1],], vor.vertices[i], far_point)
                    if intsect:
                        # Then add the intersect point to both points' lists
                        #print(intsect)
                        pps[pointidx[0], ppn[pointidx[0]], 0] = intsect[0]
                        pps[pointidx[0], ppn[pointidx[0]], 1] = intsect[1]
                        ppn[pointidx[0]] = ppn[pointidx[0]] + 1
                        pps[pointidx[1], ppn[pointidx[1]], 0] = intsect[0]
                        pps[pointidx[1], ppn[pointidx[1]], 1] = intsect[1]
                        ppn[pointidx[1]] = ppn[pointidx[1]] + 1
                        nintsect = nintsect + 1
                #if nintsect == 1:
                if Point(np.around(vor.vertices[i], decimals = 10)).within(polygon):
                    # If the vertex is inside the hull, add this vertice to both points' lists
                    pps[pointidx[0], ppn[pointidx[0]], 0] = vor.vertices[i][0]
                    pps[pointidx[0], ppn[pointidx[0]], 1] = vor.vertices[i][1]
                    ppn[pointidx[0]] = ppn[pointidx[0]] + 1
                    pps[pointidx[1], ppn[pointidx[1]], 0] = vor.vertices[i][0]
                    pps[pointidx[1], ppn[pointidx[1]], 1] = vor.vertices[i][1]
                    ppn[pointidx[1]] = ppn[pointidx[1]] + 1

            else:  # if the ridge has two finite end points (vertices)
                inh0 = Point(np.around(vor.vertices[simplex[0]], decimals = 10)).within(polygon)  # first vertex inside the polygon?
                inh1 = Point(np.around(vor.vertices[simplex[1]], decimals = 10)).within(polygon)  # second vertex inside the polygon?
                if inh0 and inh1:
                    # Add both vertices to both points' lists
                    pps[pointidx[0], ppn[pointidx[0]], 0] = vor.vertices[simplex[0]][0]
                    pps[pointidx[0], ppn[pointidx[0]], 1] = vor.vertices[simplex[0]][1]
                    ppn[pointidx[0]] = ppn[pointidx[0]] + 1
                    pps[pointidx[0], ppn[pointidx[0]], 0] = vor.vertices[simplex[1]][0]
                    pps[pointidx[0], ppn[pointidx[0]], 1] = vor.vertices[simplex[1]][1]
                    ppn[pointidx[0]] = ppn[pointidx[0]] + 1
                    pps[pointidx[1], ppn[pointidx[1]], 0] = vor.vertices[simplex[0]][0]
                    pps[pointidx[1], ppn[pointidx[1]], 1] = vor.vertices[simplex[0]][1]
                    ppn[pointidx[1]] = ppn[pointidx[1]] + 1
                    pps[pointidx[1], ppn[pointidx[1]], 0] = vor.vertices[simplex[1]][0]
                    pps[pointidx[1], ppn[pointidx[1]], 1] = vor.vertices[simplex[1]][1]
                    ppn[pointidx[1]] = ppn[pointidx[1]] + 1
                elif inh0 and not inh1:
                    # Add first vertice to both points' lists
                    pps[pointidx[0], ppn[pointidx[0]], 0] = vor.vertices[simplex[0]][0]
                    pps[pointidx[0], ppn[pointidx[0]], 1] = vor.vertices[simplex[0]][1]
                    ppn[pointidx[0]] = ppn[pointidx[0]] + 1
                    pps[pointidx[1], ppn[pointidx[1]], 0] = vor.vertices[simplex[0]][0]
                    pps[pointidx[1], ppn[pointidx[1]], 1] = vor.vertices[simplex[0]][1]
                    ppn[pointidx[1]] = ppn[pointidx[1]] + 1
                    # Then find the intersect point with a border
                    for simplex2 in edges:
                        intsect = seg_intersect(corners[simplex2[0],], corners[simplex2[1],], vor.vertices[simplex[0]], vor.vertices[simplex[1]])
                        if intsect:
                            # Add the intersect point to both points' lists
                            #print(intsect)
                            pps[pointidx[0], ppn[pointidx[0]], 0] = intsect[0]
                            pps[pointidx[0], ppn[pointidx[0]], 1] = intsect[1]
                            ppn[pointidx[0]] = ppn[pointidx[0]] + 1
                            pps[pointidx[1], ppn[pointidx[1]], 0] = intsect[0]
                            pps[pointidx[1], ppn[pointidx[1]], 1] = intsect[1]
                            ppn[pointidx[1]] = ppn[pointidx[1]] + 1
                            break
                elif inh1 and not inh0:
                    # Add second vertice to both points' lists
                    pps[pointidx[0], ppn[pointidx[0]], 0] = vor.vertices[simplex[1]][0]
                    pps[pointidx[0], ppn[pointidx[0]], 1] = vor.vertices[simplex[1]][1]
                    ppn[pointidx[0]] = ppn[pointidx[0]] + 1
                    pps[pointidx[1], ppn[pointidx[1]], 0] = vor.vertices[simplex[1]][0]
                    pps[pointidx[1], ppn[pointidx[1]], 1] = vor.vertices[simplex[1]][1]
                    ppn[pointidx[1]] = ppn[pointidx[1]] + 1
                    # Then find the intersect point with a border
                    for simplex2 in edges:
                        intsect = seg_intersect(corners[simplex2[0],], corners[simplex2[1],], vor.vertices[simplex[0]], vor.vertices[simplex[1]])
                        if intsect:
                            # Add the intersect point to both points' lists
                            #print(intsect)
                            pps[pointidx[0], ppn[pointidx[0]], 0] = intsect[0]
                            pps[pointidx[0], ppn[pointidx[0]], 1] = intsect[1]
                            ppn[pointidx[0]] = ppn[pointidx[0]] + 1
                            pps[pointidx[1], ppn[pointidx[1]], 0] = intsect[0]
                            pps[pointidx[1], ppn[pointidx[1]], 1] = intsect[1]
                            ppn[pointidx[1]] = ppn[pointidx[1]] + 1
                            break
                else:
                    # Both vertices are outside the area
                    # If the line segment connecting the two vertices cuts through a border, then add the intersect point to both points' lists
                    for edge in edges:
                        intsect = seg_intersect(corners[edge[0]], corners[edge[1]], vor.vertices[simplex[0]], vor.vertices[simplex[1]])
                        if intsect:
                            # Add the intersect point to both points' lists
                            #print(intsect)
                            pps[pointidx[0], ppn[pointidx[0]], 0] = intsect[0]
                            pps[pointidx[0], ppn[pointidx[0]], 1] = intsect[1]
                            ppn[pointidx[0]] = ppn[pointidx[0]] + 1
                            pps[pointidx[1], ppn[pointidx[1]], 0] = intsect[0]
                            pps[pointidx[1], ppn[pointidx[1]], 1] = intsect[1]
                            ppn[pointidx[1]] = ppn[pointidx[1]] + 1
        # Add corner points to points' lists
        for pt in range(points.shape[0]):  # for each point
            for cn in corners:
                not_this_corner = 0
                for pointidx, simplex in zip(vor.ridge_points, vor.ridge_vertices):  # for each ridge
                    simplex = np.asarray(simplex)
                    if pointidx[0] != pt and pointidx[1] != pt:  # if neither of the ridge's generating points is the pt in discussion, then go to next ridge
                        continue
                    if np.any(simplex < 0):  # if the ridge is an extreme ray
                        i = simplex[simplex >= 0][0] # finite end Voronoi vertex
                        t = points[pointidx[1]] - points[pointidx[0]]  # tangent
                        t = t / np.linalg.norm(t)
                        n = np.array([-t[1], t[0]]) # normal
                        midpoint = points[pointidx].mean(axis=0)
                        far_point = vor.vertices[i] + np.sign(np.dot(midpoint - center, n)) * n * 1000
                        intsect = seg_intersect(points[pt], cn, vor.vertices[i], far_point)
                        if intsect:  # if the ray intersects with the line segment connecting the pt in discussion and the corner in dicussion, then the corner should not belong to the pt's cell
                            not_this_corner = 1
                            break
                    else:
                        intsect = seg_intersect(points[pt], cn, vor.vertices[simplex[0]], vor.vertices[simplex[1]])
                        if intsect:
                            not_this_corner = 1
                            break
                if not_this_corner == 0:
                    pps[pt, ppn[pt], 0] = cn[0]
                    pps[pt, ppn[pt], 1] = cn[1]
                    ppn[pt] = ppn[pt] + 1
        centermove = 0
        for dp in range(ndepots):
            pivots = np.unique(pps[dp,0:ppn[dp]], axis=0)
            (x, y, radius) = make_circle(pivots)
            new_points[dp] = np.array([x, y])
            dist[dp] = radius

            # Is the center point of this MCC in the polygon and not in any hole? If no, use Wei et al (2006) method to find a feasible center
            (MCCfeasible, whereMCC) = center_feasible(new_points[dp])
            if not MCCfeasible:
                print("Iter: {0:d} dp: {1:d} MCC infeasible. ".format(itercnt, dp) + whereMCC)
                verbose_one = 0
                
                if itercnt == 1:
                    verbose_one = 1
                    if dp == 0:
                        test_pivots = np.copy(pivots)
                        test_MCCradius = dist[dp]
                        test_whereMCC = whereMCC
                        test_MCCcenter = np.copy(new_points[dp])
                        print("Saved test points:")
                        print(test_MCCradius)
                        print(test_MCCcenter)
                else:
                    verbose_one = 0
                               
                start_time = time.time()
                if cmcc_method == "Wei":
                    (new_points[dp], dist[dp], run_stats) = Wei2006(pivots, dist[dp])
                elif cmcc_method == "Wei_v2":
                    (new_points[dp], dist[dp], run_stats) = Wei2006_v2(pivots, dist[dp], whereMCC, verbose_one)
                elif cmcc_method == "Liu":
                    (new_points[dp], dist[dp], run_stats) = Liu2020(pivots, new_points[dp], dist[dp], whereMCC, verbose_one)
                elif cmcc_method == "Liu2021a":
                    (new_points[dp], dist[dp], run_stats) = Liu2021a(pivots, new_points[dp], dist[dp], whereMCC, verbose_one, early = 1)
                else:
                    print("Unknown method")

                # tally the run performance
                total_method_calls = total_method_calls + 1
                total_time_on_method = total_time_on_method + time.time() - start_time
                total_n_distance_two_points_calls = total_n_distance_two_points_calls + run_stats['n_distance_two_points_calls']
                total_n_bisect_line_segment_calls = total_n_bisect_line_segment_calls + run_stats['n_bisect_line_segment_calls']
                total_n_project_point_to_line_segment_calls = total_n_project_point_to_line_segment_calls + run_stats['n_project_point_to_line_segment_calls']
                if cmcc_method == "Liu":
                    n_edges_skipped = n_edges_skipped + run_stats['SKP']
                    n_found_by_1 = n_found_by_1 + run_stats['CL1']
                    n_list_truncations = n_list_truncations + run_stats['LTR']
                    n_edges_truncated = n_edges_truncated + run_stats['NTR']
                    n_prune_by_ub_1_point = n_prune_by_ub_1_point + run_stats['CL2']
                    n_found_by_2 = n_found_by_2 + run_stats['CL2']
                    n_vertex_pairs_skipped = n_vertex_pairs_skipped + run_stats['CL4']
                    n_prune_by_ub_2_point = n_prune_by_ub_2_point + run_stats['UB2']
                    n_prune_by_lb = n_prune_by_lb + run_stats['LB1']
                if cmcc_method == "Liu2021a":
                    n_edges_skipped = n_edges_skipped + run_stats['SKP']
                    n_found_by_1 = n_found_by_1 + run_stats['CL1']
                    n_list_truncations = n_list_truncations + run_stats['LTR']
                    n_edges_truncated = n_edges_truncated + run_stats['NTR']
                    n_prune_by_ub_1_point = n_prune_by_ub_1_point + run_stats['UB1']
                    n_found_by_2 = n_found_by_2 + run_stats['CL2']
                    n_Megiddo_calls = n_Megiddo_calls + run_stats['MGD']
                    n_edges = n_edges + run_stats['TOT']
                    
            this_centermove = np.linalg.norm(new_points[dp] - points[dp])
            if this_centermove > centermove:
                centermove = this_centermove
        distmax = np.max(dist)
        distmin = np.min(dist)
        distgap = distmax - distmin
        iterlog[itercnt] = np.array([itercnt, distmax, distmin, distgap, centermove])
        points = np.copy(new_points)
        iter_time = time.time() - iter_time

    finish_points = points
    finish_dist = distmax

    # Plot finish up solution
    plt.figure(figsize=(8, 8))
    plt.axis('scaled')
    plt.xlim((xmin-pmar,xmax+pmar))
    plt.ylim((ymin-pmar,ymax+pmar))
    plt.title("Radius:" + "{:.3f}".format(finish_dist) + " Function time:" + "{:.1f}".format(total_time_on_method)
              + " p2p:"+"{:.0f}".format(total_n_distance_two_points_calls)
              + " p2l:"+"{:.0f}".format(total_n_project_point_to_line_segment_calls)
              + " bis:"+"{:.0f}".format(total_n_bisect_line_segment_calls))
    for simplex in edges:
        plt.plot(corners[simplex,0], corners[simplex,1], 'k-')
    for this_hole in hole_file_names:
        x,y = holes_polygon[this_hole].exterior.xy
        plt.plot(x,y)
    plt.plot(finish_points[:, 0], finish_points[:, 1], 'o')
    fig = plt.gcf()
    fig.set_size_inches(8,8)
    ax = fig.gca()
    for i in range(ndepots):
        circle = plt.Circle((finish_points[i,0], finish_points[i,1]), finish_dist, color='b', fill=False)
        ax.add_artist(circle)
    pdf.savefig()
    plt.draw()
    #plt.show()
    plt.close()

# Print the solution and performance stats
print("ndepots: {:d}".format(ndepots))
print("Iters: {:d}".format(itercnt))
print("Method: " + cmcc_method)
print("Finish radius: " + str(finish_dist))
print("P2P: {:d}".format(total_n_distance_two_points_calls))
print("P2L: {:d}".format(total_n_project_point_to_line_segment_calls))
print("L2L: {:d}".format(total_n_bisect_line_segment_calls))
print("Total time in function: {:f}".format(total_time_on_method))
print("Total method calls: {:d}".format(total_method_calls))
if cmcc_method == "Liu":
    print("SKP: {0:<d} CL1: {1:<d} LTR: {2:<d} NTR: {3:<d} UB1: {4:<d} CL2: {5:<d} CL4: {6:<d} UB2: {7:<d} LB1: {8:<d}".format(
        n_edges_skipped, n_found_by_1, n_list_truncations,n_edges_truncated,n_prune_by_ub_1_point,n_found_by_2,
        n_vertex_pairs_skipped,n_prune_by_ub_2_point,n_prune_by_lb))
if cmcc_method == "Liu2021a":
    print("SKP: {0:<d} CL1: {1:<d} NTR: {2:<d} MGD: {3:<d} TOT: {4:<d}".format(
        n_edges_skipped, n_found_by_1, n_edges_truncated, n_Megiddo_calls, n_edges))



# Write output to KML
def DistSq2KML(r = 10, rate = sqlen):
    radius = r/100*rate
    return radius

def circleinKML(centerpoints, radius, utmnumber = utmnumber, utmletter = utmletter):
    polycirclelst = list()
    pollst = list()
    j = 0
    kml = simplekml.Kml()
    multipnt = kml.newmultigeometry(name="MultiPoint")
    for i in centerpoints:
        (latitude,longitude) = utm.to_latlon((i[0]/100*sqlen*(1+border*2)+origx),(i[1]/100*sqlen*(1+border*2)+origy),int(utmnumber),utmletter)
        #print(latitude,longitude)
        multipnt.newpoint(coords=[(longitude,latitude)])
        polycirclelst.append(polycircles.Polycircle(latitude=latitude,
                                        longitude=longitude,
                                        radius=radius,
                                        number_of_vertices=36))

        pollst.append(kml.newpolygon(name="Circle"+str(j),
                                             outerboundaryis=polycirclelst[j].to_kml()))
        pollst[j].style.polystyle.color = \
            simplekml.Color.changealphaint(200, simplekml.Color.lightgreen)
        multipnt.style.labelstyle.scale = 0.0 # Hide the labels of the points
        j = j+1
    kml.save(args["sol"]+".kml")
    

# Plot solution
plt.close()
plt.figure(figsize=(6.4, 4.8))
plt.axis('scaled')
plt.axis('off')
pmar = 10
plt.xlim((xmin-pmar,xmax+pmar))
plt.ylim((ymin-pmar-10,ymax+pmar))
for simplex in edges:
    plt.plot(corners[simplex,0], corners[simplex,1], 'k-')
for this_hole in hole_file_names:
    x,y = holes_polygon[this_hole].exterior.xy
    plt.plot(x,y)
plt.plot(finish_points[:, 0], finish_points[:, 1], 'o')
fig = plt.gcf()
fig.set_size_inches(8,8)
ax = fig.gca()
for i in range(ndepots):
    circle = plt.Circle((finish_points[i,0], finish_points[i,1]), finish_dist, color='b', fill=False)
    ax.add_artist(circle)
plt.savefig(args["pdf"]+'.pdf')

circleinKML(centerpoints=finish_points, radius=DistSq2KML(finish_dist))
